<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content=""><meta name="keywords" content=""><meta name="author" content="沈留白"><meta name="copyright" content="沈留白"><title>人生如逆旅，我亦是行人 | 沈留白の博客</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js"></script><script src="https://cdn.jsdelivr.net/npm/blueimp-md5@2.10.0/js/md5.min.js"></script><link rel="dns-prefetch" href="https://hm.baidu.com"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?15a2cd71aee2ddf6ffb703d39beb34be";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();</script><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
} </script><meta name="generator" content="Hexo 4.2.1"></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="false"><div class="author-info"><div class="author-info__avatar text-center"><img src="https://snowysound.github.io/img/avatar.png"></div><div class="author-info__name text-center">沈留白</div><div class="author-info__description text-center"></div><div class="follow-button"><a href="https://github.com/SnowySound" target="_blank" rel="noopener">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">199</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">41</span></a></div></div></div><nav id="nav" style="background-image: url(https://my-blogimage.oss-cn-qingdao.aliyuncs.com/img/home.png)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">沈留白の博客</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">首页</a><a class="site-page" href="/archives">归档</a><a class="site-page" href="/tags">标签</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> 搜索</span></a></span></div><div id="site-info"><div id="site-title">沈留白の博客</div><div id="site-sub-title">人生如逆旅，我亦是行人</div></div></nav><div id="content-outer"><div class="layout" id="content-inner"><div class="recent-post-item article-container"><a class="article-title" href="/2020/11/13/Vue-%E7%9A%84-diff-%E7%AE%97%E6%B3%95/">Vue 的 diff 算法</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-11-13</time><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Vue/">Vue</a></span><div class="content">概念vue2.0加入了virtual dom，有点向react靠拢的意思。vue的diff位于patch.js文件中，复杂度为O(n)。diff 算法是一种通过同层的数节点进行比较的高效算法，避免了对树进行逐层搜索遍历，diff 算法在很多场景下都有应用，例如在 Vue 虚拟 dom 渲染成真实 dom 的新旧 VNode 节点比较更新时，就用到了该算法。diff 算法有两个比较显著的特点。

比较只会在同层级进行，不会跨级比较
在 diff 比较的过程中循环从两边向中间收拢  

虚拟 dom所谓的 virtual dom，也就是虚拟节点。它通过 JS 的 Object 对象模拟 DOM 中的节点，然后再通过特定的 render 方法将其渲染成真正的 DOM 节点 dom diff 则是通过 JS 层面的计算，返回一个 patch 对象，即补丁对象，再通过特定的操作解析 patch 对象，完成页面的重新渲染：

diff 算法本着对 diff 过程的认识和对 Vue 源码的学习，我们通过 Vue 源码的解读和实例分析来理清楚 diff 算法的整个流程，下面把整个 diff 流程拆分成三步来具体分析：
第一步Vue 的虚拟 dom 渲染真实 dom 的过程首先会对新老 VNode 的开始和结束位置进行标记：oldStartIdx, oldEndIdx,newStartIdx,new ...</div><a class="more" href="/2020/11/13/Vue-%E7%9A%84-diff-%E7%AE%97%E6%B3%95/#more" style="margin-top: 14px">阅读更多</a><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/11/11/JS-%E4%B9%8B%E5%8E%9F%E5%9E%8B/">JS 之继承与原型链</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-11-11</time><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/JavaScript/">JavaScript</a></span><div class="content">概念
当谈到继承时，JavaScript 只有一种结构：对象。每个实例对象（object）都有一个私有属性（称之为 __proto__）指向它的构造函数的原型对象(prototype)。该原型对象也有一个自己的原型对象(__proto__)，层层向上直到一个对象的原型对象为 null。根据定义，null 没有原型，并作为这个原型链中的最后一个环节


继承，原型，原型链关系理解
__proto__


Every JavaScript object has a second JavaScript object (or null ,but this is rare) associated with it. This second object is known as a prototype, and the first object inherits properties from the prototype.


123456789101112let a = &#123;&#125;;function Foo() &#123;&#125;;let f1 = new Foo();console.log(a.__proto__ === Object.prototype);// trueconsole.log(f1.__proto__ === Foo.prototype); // tru ...</div><a class="more" href="/2020/11/11/JS-%E4%B9%8B%E5%8E%9F%E5%9E%8B/#more" style="margin-top: 14px">阅读更多</a><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/11/07/JS-%E8%8E%B7%E5%8F%96%E6%9C%AC%E5%9C%B0%E6%96%87%E4%BB%B6/">JS 获取本地文件</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-11-07</time><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/JavaScript/">JavaScript</a></span><div class="content">前言在上一篇博客 (vue + element upload 实现上传 excel) 中实现了上传 excel 文件。而在这篇文章中将详细讲述一下，如何获取本地文件，并通过  formdata 将其上传到服务器
JS 文件上传&lt;input type=&quot;file&quot;&gt;
使用 type=”file” 的 &lt;input&gt; 元素使得用户可以选择一个或多个元素以提交表单的方式上传到服务器上，或者通过 Javascript 的 File API 对文件进行操作。

&lt;input type=&quot;file&quot;&gt; 中有一个属性 accept, 这个属性用来界定接收的文件类型
常见的属性值：

audio/* 接收所有的声音文件
video/* 接收所有的视频文件
image/* 接收所有的图像文件

&lt;input type=&quot;file&quot; accept=&quot;image/gif, image/jpeg&quot; /&gt;多属性一起使用，需要在中间加 “,” 分隔。/后面可以界定文件后缀。
注意请不要将该属性作为唯一的验证工具，应该在服务器上对文件上传进行验证。
&lt;input type=&quot;file&quot;&gt; 中有一个属性值 multiple, 当添加 multiple=”m ...</div><a class="more" href="/2020/11/07/JS-%E8%8E%B7%E5%8F%96%E6%9C%AC%E5%9C%B0%E6%96%87%E4%BB%B6/#more" style="margin-top: 14px">阅读更多</a><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/11/05/vue-element-upload-%E5%AE%9E%E7%8E%B0%E4%B8%8A%E4%BC%A0-excel/">vue + element upload 实现上传 excel</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-11-05</time><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Vue/">Vue</a></span><div class="content">前言  在开发中，会碰到上传 excel 的情况，记录一下 vue+element upload 实现过程
实现效果
代码12345678910111213141516171819&lt;div style="margin-top: 10px;"&gt;  &lt;el-input v-model="uploadFileName" style="width: 280px;"&gt;&lt;/el-input&gt;  &lt;el-upload    ref="upload"    class="upload-demo"    accept=".xlsx"    action=""    :auto-upload="false"    :show-file-list="false"    :on-change="fileChange"  &gt;    &lt;el-button type="primary"&gt;      选取文件    &lt;/el-button&gt;  &lt;/el-upload&gt;  &lt;el-button type="success" @click="uploadFile"&gt;    上传到服务器  &lt;/el-button&gt;&lt;/div&gt;
1234567891011121314151617181920212223 ...</div><a class="more" href="/2020/11/05/vue-element-upload-%E5%AE%9E%E7%8E%B0%E4%B8%8A%E4%BC%A0-excel/#more" style="margin-top: 14px">阅读更多</a><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/10/30/JS-%E4%B9%8B-typeof-instanceof-obj-constructor/">JS  之 typeof, instanceof &amp;&amp; obj.constructor</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-10-30</time><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/JavaScript/">JavaScript</a></span><div class="content">typeof 用以获取一个变量或者是表达式的类型可分辨内容为： number, boolean, string, function, object(array, null, date 都只能判断成 object), undefined
12345678910// 测试 typeof 用法console.log(typeof 123); // numberconsole.log(typeof true); // booleanconsole.log(typeof '123'); // stringconsole.log(typeof function() &#123;&#125;); // functionconsole.log(typeof &#123;&#125;); // objectconsole.log(typeof []); // objectconsole.log(typeof new Date()); // objectconsole.log(typeof null); // objectconsole.log(typeof undefined); // undefined

instanceof 用于判断一个变量是否是某个对象的实例
操作符 instanceof 测试构造函数的 prototype 属性是否出现在对象的 prototype 链的任何位置。返回值是布尔 ...</div><a class="more" href="/2020/10/30/JS-%E4%B9%8B-typeof-instanceof-obj-constructor/#more" style="margin-top: 14px">阅读更多</a><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/10/27/JS-%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E6%B7%B1%E6%8B%B7%E8%B4%9D/">JS 实现一个深拷贝</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-10-27</time><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/JavaScript/">JavaScript</a></span><div class="content">原文
一个满足 80% 情况的简单解决方案
序列化/反序列化 方法

123// JSON.stringify(); 将对象序列化成 JSON 字符串// JSON.parse();将 JSON 字符串反序列化成对象const newObj = JSON.parse(JSON.stringify(oldObj));

20% 的异常情况
无法实现对函数，RegExp 等特殊对象的克隆
会抛弃对象的 constructor, 所有的构造函数会指向 Object

1234567891011121314151617181920212223242526272829// 构造函数function person(pname) &#123;  this.name = pname;&#125;const Messi = new person('Messi');// 函数function say() &#123;  console.log('hi');&#125;;const oldObj = &#123;  a: say,  b: new Array(1),  c: new RegExp('ab+c', 'i'),  d: Messi&#125;;const newObj = JSON.parse(JSON.stringify(oldObj));// 无法复制函数console.log(newO ...</div><a class="more" href="/2020/10/27/JS-%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E6%B7%B1%E6%8B%B7%E8%B4%9D/#more" style="margin-top: 14px">阅读更多</a><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/10/21/module-exports-%E4%B8%8E-exports-export-%E4%B8%8E-export-default-%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB%E5%92%8C%E5%8C%BA%E5%88%AB/">module.exports 与 exports, export 与 export default 之间的关系和区别</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-10-21</time><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/JavaScript/">JavaScript</a></span><div class="content">前言一个很重要的知识点： CommonJS 模块规范和 ES6 模块规范是不同的概念
CommonJS 模块规范Node 应用由模块组成， 采用 CommonJS 模块规范。
根据这个规范，每一个文件就是一个模块，有自己的作用域。在一个文件里面定义的变量，函数，类都是私有的，对其他文件不可见。

CommonJS定义的模块分为: 模块标识(module)、模块定义(exports) 、模块引用(require)

换言之CommonJS 规范规定，每个模块内部， module 变量代表当前模块。这个变量是一个对象，它的 exports 属性（即 module.exports）是对外的接口。加载某个模块，其实是加载该模块的 module.exports 属性。

module.exports 导出变量
123456789let testX = 0;let testY = function () &#123;  console.log('this is just an example of test')&#125;;module.exports.x = testX;module.exports.y = testY;// 如果要对数值，数组，函数直接引出，不加键值，则只有一种方法module.export = 123;// exports = 123; 虽然可以执行，但是module.e ...</div><a class="more" href="/2020/10/21/module-exports-%E4%B8%8E-exports-export-%E4%B8%8E-export-default-%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB%E5%92%8C%E5%8C%BA%E5%88%AB/#more" style="margin-top: 14px">阅读更多</a><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/10/19/JS-%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6Mocha/">JS 测试框架 Mocha</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-10-19</time><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/JavaScript/">JavaScript</a></span><div class="content">前言
Mocha 诞生于 2011 年，是目前最流行的 JavaScript 测试框架之一。
在浏览器和 Node 环境下都可以使用。
测试框架还有 Jasmine, Karma, Tape

Mocha 工程结构123456789101112131415test&#x2F;|+- .vscode&#x2F;|  ||  +- launch.json &lt;-- VSCode 配置文件|+- hello.js &lt;-- 待测试js文件|+- test&#x2F; &lt;-- 存放所有test｜ ｜|  +- hello-test.js &lt;-- 测试文件|+- package.json &lt;-- 项目描述文件|+- node_modules&#x2F; &lt;-- npm安装的所有依赖包

Mocha 安装在 package.json 中添加依赖 Mocha, 需要注意的是要将 Mocha 添加到 “devDependencies” 中，而不是 “dependencies”
123456789// package.json// 如果一个模块在运行时并不需要，仅仅在开发时才需要，就可以放到 devDependencies 中。这样，正式打包发布时， devDependencies 的包不会被包含进来。&#123;  ...  "dependencies": &#12 ...</div><a class="more" href="/2020/10/19/JS-%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6Mocha/#more" style="margin-top: 14px">阅读更多</a><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/10/16/ES6-%E4%B9%8B-export-%E4%B8%8E-import/">ES6 之 export 与 import</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-10-16</time><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/JavaScript/">JavaScript</a></span><div class="content">前言
ES6 中的 一个模块是一个包含了 JS 代码的文件，在一个模块中，其所有的变量都是对其他模块不可见的，除非我们导出它们。模块化规范： 即为 JavaScript 提供一种模块编写、模块依赖和


ES6  的模块自动开启严格模式，即使你没有写 ‘use strict’
可以在模块中使用 import 和 export

模块导出 export
export 可以导出所有的最外层函数, 类以及var, let 或 const 声明的变量。ES6 模块只支持静态的导入和导出，所以只能在函数的最外层作用域使用 import 和 export，不可以在条件语句中使用也不可以在函数作用域内使用，所有导出的标识符一定要在源码中明确的导出他们的名称。

名字导出 (name export)1234567891011121314export function test (x, y) &#123;  if (Number(x) &amp;&amp; Number(y)) &#123;    return x + y;  &#125; else &#123;    alert ('输入格式有误！')  &#125;&#125;// 导出重命名export &#123;  test as testA,  test as testB&#125;
可以在 function, class, var,  ...</div><a class="more" href="/2020/10/16/ES6-%E4%B9%8B-export-%E4%B8%8E-import/#more" style="margin-top: 14px">阅读更多</a><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/10/10/Axure-RP-9-%E6%AD%A3%E5%BC%8F%E7%89%88%E5%AF%86%E9%92%A5%E5%88%86%E4%BA%AB/">Axure RP 9 正式版密钥分享</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-10-10</time><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/%E7%99%BD%E5%AB%96%E5%BA%93/">白嫖库</a></span><div class="content">
  温馨提示：资源来自互联网，请支持正版。


  
    被授权人（License）: AX9001
    
    授权码（Key）：iy9uUKbS7pEZwE5hbHTGigOcu48TdY4JXWbJYHxXLuvAzRL8qmry9J2mS5wXO7y3
  
  
    被授权人（License）: AX9003
    
    授权码（Key）：sOujdwe3jIWrmoe9S13mb42hKJWcRBe6L+CZwNsC4OluYXGVPFd+KiQjpdM56fpG
  
  
    被授权人（License）: AX9003
    
    授权码（Key）：NT/mS+29Kgtw46K0kQBgE3X5qzPwKhSLSM20lhdVQ2bH593Quez3lphi8AAgA1Ax
  



</div><a class="more" href="/2020/10/10/Axure-RP-9-%E6%AD%A3%E5%BC%8F%E7%89%88%E5%AF%86%E9%92%A5%E5%88%86%E4%BA%AB/#more" style="margin-top: 14px">阅读更多</a><hr></div><nav id="pagination"><div class="pagination"><a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-chevron-left"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/20/">20</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer class="footer-bg" style="background-image: url(https://my-blogimage.oss-cn-qingdao.aliyuncs.com/img/home.png)"><div class="layout" id="footer"><div class="copyright">&copy;2019 - 2023 By 沈留白</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody" target="_blank" rel="noopener"><span>Melody</span></a></div><div class="footer_custom_text"><a href="https://beian.miit.gov.cn" target="_blank" rel="noopener">鲁ICP备19020181号</a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv"><i class="fa fa-user"></i><span id="busuanzi_value_site_uv"></span><span></span></span><span class="footer-separator">|</span><span id="busuanzi_container_site_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_site_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.7.0"></script><script src="/js/fancybox.js?version=1.7.0"></script><script src="/js/sidebar.js?version=1.7.0"></script><script src="/js/copy.js?version=1.7.0"></script><script src="/js/transition.js?version=1.7.0"></script><script src="/js/scroll.js?version=1.7.0"></script><script src="/js/head.js?version=1.7.0"></script><script src="/js/search/local-search.js"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="noopener" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body></html>