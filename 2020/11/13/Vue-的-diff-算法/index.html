<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="description" content="Vue 的 diff 算法"><meta name="keywords" content="Vue"><meta name="author" content="沈留白"><meta name="copyright" content="沈留白"><title>Vue 的 diff 算法 | 沈留白の博客</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js"></script><script src="https://cdn.jsdelivr.net/npm/blueimp-md5@2.10.0/js/md5.min.js"></script><link rel="dns-prefetch" href="https://hm.baidu.com"><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?15a2cd71aee2ddf6ffb703d39beb34be";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><script>var GLOBAL_CONFIG={root:"/",algolia:void 0,localSearch:{path:"search.xml",languages:{hits_empty:"找不到您查询的内容:${query}"}},copy:{success:"复制成功",error:"复制错误",noSupport:"浏览器不支持"}}</script><meta name="generator" content="Hexo 4.2.1"></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#概念"><span class="toc-number">1.</span> <span class="toc-text">概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#虚拟-dom"><span class="toc-number">2.</span> <span class="toc-text">虚拟 dom</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#diff-算法"><span class="toc-number">3.</span> <span class="toc-text">diff 算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#第一步"><span class="toc-number">3.1.</span> <span class="toc-text">第一步</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#第二步"><span class="toc-number">3.2.</span> <span class="toc-text">第二步</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#第三步"><span class="toc-number">3.3.</span> <span class="toc-text">第三步</span></a></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://snowysound.github.io/img/avatar.png"></div><div class="author-info__name text-center">沈留白</div><div class="author-info__description text-center"></div><div class="follow-button"><a href="https://github.com/SnowySound" target="_blank" rel="noopener">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">202</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">43</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image:url(https://my-blogimage.oss-cn-qingdao.aliyuncs.com/img/home.png)"><div id="page-header"><span class="pull-left"><a id="site-name" href="/">沈留白の博客</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"> <a class="site-page" href="/">首页</a><a class="site-page" href="/archives">归档</a><a class="site-page" href="/tags">标签</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> 搜索</span></a></span></div><div id="post-info"><div id="post-title">Vue 的 diff 算法</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-11-13</time><div class="post-meta-wordcount"><span>字数总计: </span><span class="word-count">2.4k</span><span class="post-meta__separator">|</span><span>阅读时长: 8 分钟</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>vue2.0加入了virtual dom，有点向react靠拢的意思。vue的diff位于<a href="https://github.com/vuejs/vue/blob/dev/src/core/vdom/patch.js" target="_blank" rel="noopener">patch.js</a>文件中，复杂度为O(n)。diff 算法是一种通过同层的数节点进行比较的高效算法，避免了对树进行逐层搜索遍历，diff 算法在很多场景下都有应用，例如在 Vue 虚拟 dom 渲染成真实 dom 的新旧 VNode 节点比较更新时，就用到了该算法。diff 算法有两个比较显著的特点。</p><ul><li>比较只会在同层级进行，不会跨级比较<br><img src="https://my-blogimage.oss-cn-qingdao.aliyuncs.com/img/diff00.png" alt="diff同级比较"></li><li>在 diff 比较的过程中循环从两边向中间收拢<br><img src="https://my-blogimage.oss-cn-qingdao.aliyuncs.com/img/diff01.png" alt="diff执行特点"></li></ul><h2 id="虚拟-dom"><a href="#虚拟-dom" class="headerlink" title="虚拟 dom"></a>虚拟 dom</h2><p>所谓的 virtual dom，也就是虚拟节点。它通过 JS 的 Object 对象模拟 DOM 中的节点，然后再通过特定的 render 方法将其渲染成真正的 DOM 节点 dom diff 则是通过 JS 层面的计算，返回一个 patch 对象，即补丁对象，再通过特定的操作解析 patch 对象，完成页面的重新渲染：</p><p><img src="https://my-blogimage.oss-cn-qingdao.aliyuncs.com/img/virtualdom.png" alt="虚拟 dom"></p><h2 id="diff-算法"><a href="#diff-算法" class="headerlink" title="diff 算法"></a>diff 算法</h2><p>本着对 diff 过程的认识和对 Vue 源码的学习，我们通过 Vue 源码的解读和实例分析来理清楚 diff 算法的整个流程，下面把整个 diff 流程拆分成三步来具体分析：</p><h3 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h3><p>Vue 的虚拟 dom 渲染真实 dom 的过程首先会对新老 VNode 的开始和结束位置进行标记：oldStartIdx, oldEndIdx,newStartIdx,newEndIdx。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> oldStartIdx = <span class="number">0</span> <span class="comment">// 旧节点开始下标</span></span><br><span class="line"><span class="keyword">let</span> newStartIdx = <span class="number">0</span> <span class="comment">// 新节点开始下标</span></span><br><span class="line"><span class="keyword">let</span> oldEndIdx = oldCh.length - <span class="number">1</span> <span class="comment">// 旧节点结束下标</span></span><br><span class="line"><span class="keyword">let</span> oldStartVnode = oldCh[<span class="number">0</span>] <span class="comment">//旧节点开始 vnode</span></span><br><span class="line"><span class="keyword">let</span> oldEndVnode = oldCh[oldEndIdx] <span class="comment">// 旧节点结束 vnode</span></span><br><span class="line"><span class="keyword">let</span> newEndIdx = newCh.length - <span class="number">1</span> <span class="comment">// 新节点结束下标</span></span><br><span class="line"><span class="keyword">let</span> newStartVnode = newCh[<span class="number">0</span>] <span class="comment">// 新节点开始 vnode</span></span><br><span class="line"><span class="keyword">let</span> newEndVnode = newCh[newEndIdx] <span class="comment">// 新节点结束 vnode</span></span><br></pre></td></tr></table></figure><p>经过第一步之后，我们初始的新旧 VNode 节点如下图所示：</p><p><img src="https://my-blogimage.oss-cn-qingdao.aliyuncs.com/img/diff01.png" alt="确定新旧 VNode 节点"></p><h3 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h3><p>标记好节点位置之后，就开始进入到 while 循环处理中，这里是 diff 算法的核心流程，分情况进行了新老节点的比较并移动对应的 VNode 节点。 while 循环的推出条件是知道老节点<strong>或者是</strong>新节点的开始位置大于结束位置。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIndx &lt;= newEndIdx) &#123;</span><br><span class="line">  ... <span class="comment">// 处理逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来具体介绍 while 循环中的处理逻辑，循环过程中首先对新老 VNode 节点的头尾进行比较，寻找相同节点，如果有相同节点满足 sameVnode（可复用的相同节点）则直接进行 pathVnode（该方法进行节点复用处理），并且根据具体情形，移动新老节点的 VNode 索引，以便进行下一次的循环处理，一共有 2*2=4 中情形。下面根据代码展开分析：</p><ul><li>情形一：当新老 VNode 节点的 start 满足 sameVnode 时，直接 pathVnode 即可，同时新老 VNode 节点的开始索引都加1。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (sameVnode(oldStartVnode, newStartVnode)) &#123;</span><br><span class="line">  patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx)</span><br><span class="line">  oldStartVnode = oldCh[++oldStartIdx]</span><br><span class="line">  newStartVnode = newCh[++newStartIdx]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>情形二：当新老 VNode 节点的 end 满足 sameVnode 时，同样直接 pathVnode 即可，同时新老 VNode 节点的结束索引都减1。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 承上启下</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (sameVnode(oldEndVnode, newEndVnode)) &#123;</span><br><span class="line">  patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx)</span><br><span class="line">  oldEndVnode = oldCh[--oldEndIdx]</span><br><span class="line">  newEndVnode = newCh[--newEndIdx]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>情形三：当老 VNode 节点的 start 和新 VNode 节点的 end 满足 sameVnode 时，这说明这次数据更新后 oldStartVnode 已经跑到了 oldEndVnode 后面去了。这时候在 pathVnode 后，还需要将当前真实 dom 节点移动到 oldEndVnode 的后面，同时老 VNode 节点开始索引加1，新 Vnode 节点的结束索引减一。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 承上启下</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (sameVnode(oldStartVnode, newEndVnode)) &#123; <span class="comment">// Vnode moved right</span></span><br><span class="line">  patchVnode(oldStartVnode, newEndVnode, instertedVnodeQueue, newCh, newEndIdx)</span><br><span class="line">  canMove &amp;&amp; nodeOps.instertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm))</span><br><span class="line">  oldStartVnode = oldCh[++oldStartIdx]</span><br><span class="line">  newEndVnode = newCh[--newEndIdx]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>情形四：当老 VNode 节点的 end 和新 VNode 节点的 start 满足 sameVnode 时，这说明这次数据更新后 oldEndVnode 跑到了 oldStartVnode 的前面去了。这个时候在 patchVnode 后，还需要将当前真实 dom 节点移动到 oldStartVnode 的前面，同时老 VNode 节点结束索引减1，新 VNode 节点的开始索引加1。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (sameVnode(oldEndVnode, newStartVnode)) &#123; <span class="comment">// Vnode moved right</span></span><br><span class="line">  patchVnode(oldEndVnode, newStartVnode, instertedVnodeQueue, newCh, newStartIdx)</span><br><span class="line">  canMove &amp;&amp; nodeOps.instertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm))</span><br><span class="line">  oldEndVnode = oldCh[--oldEndIdx]</span><br><span class="line">  newStartVnode = newCh[++newStartIdx]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>如果都不满足以上四种情形，那说明没有相同的节点可以复用。</strong>于是则通过查找事先建立好的以旧的 VNode 为 key 值，对应 index 序列为 value 值的哈希标。从这个哈希表中找到与 newStartVnode 一致 key 的旧的 VNode 节点，如果两者满足 sameVnode 的条件，在进行 patchVnode 的同时会将这个真实 dom 移动到 oldStartVnode 对应的真实 dom 的前面；如果没有找到，则说明当前索引下的新的 VNode 节点在旧的 VNode 队列中不存在，无法进行节点的复用，那么就只能调用 createElm 创建一个新的 dom 节点放到当前 newStartIdx 的位置。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 承上启下</span></span><br><span class="line"><span class="keyword">else</span> &#123;<span class="comment">// 没有找到相同的可以复用的节点，则新建节点处理</span></span><br><span class="line">  <span class="comment">/* 生成一个key与旧VNode的key对应的哈希表（只有第一次进来undefined的时候会生成，也为后面检测重复的key值做铺垫） 比如childre是这样的 [&#123;xx: xx, key: 'key0'&#125;, &#123;xx: xx, key: 'key1'&#125;, &#123;xx: xx, key: 'key2'&#125;] beginIdx = 0 endIdx = 2 结果生成&#123;key0: 0, key1: 1, key2: 2&#125; */</span></span><br><span class="line">  <span class="keyword">if</span> (isUndef(oldKeyToIdx)) oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx)</span><br><span class="line">  <span class="comment">/*如果newStartVnode新的VNode节点存在key并且这个key在oldVnode中能找到则返回这个节点的idxInOld（即第几个节点，下标）*/</span></span><br><span class="line">  idxInOld = isDef(newStartVnode.key)</span><br><span class="line">    ? oldKeyToIdx[newStartVnode.key]</span><br><span class="line">    : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx)</span><br><span class="line">  <span class="keyword">if</span> (isUndef(idxInOld)) &#123; <span class="comment">// New element</span></span><br><span class="line">    <span class="comment">/*newStartVnode没有key或者是该key没有在老节点中找到则创建一个新的节点*/</span></span><br><span class="line">    createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, <span class="literal">false</span>, newCh, newStartIdx)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">/*获取同key的老节点*/</span></span><br><span class="line">    vnodeToMove = oldCh[idxInOld]</span><br><span class="line">    <span class="keyword">if</span> (sameVnode(vnodeToMove, newStartVnode)) &#123;</span><br><span class="line">      <span class="comment">/*如果新VNode与得到的有相同key的节点是同一个VNode则进行patchVnode*/</span></span><br><span class="line">      patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue, newCh, newStartIdx)</span><br><span class="line">      <span class="comment">//因为已经patchVnode进去了，所以将这个老节点赋值undefined</span></span><br><span class="line">      oldCh[idxInOld] = <span class="literal">undefined</span></span><br><span class="line">      <span class="comment">/*当有标识位canMove实可以直接插入oldStartVnode对应的真实Dom节点前面*/</span></span><br><span class="line">      canMove &amp;&amp; nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// same key but different element. treat as new element</span></span><br><span class="line">      <span class="comment">/*当新的VNode与找到的同样key的VNode不是sameVNode的时候（比如说tag不一样或者是有不一样type的input标签），创建一个新的节点*/</span></span><br><span class="line">      createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, <span class="literal">false</span>, newCh, newStartIdx)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  newStartVnode = newCh[++newStartIdx]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再来看我们的实例，第一次循环后，找到了旧节点的末尾和新节点的开头（都是 D）相同，于是直接复用 D 节点作为 diff 后创建的第一个真实节点。同时旧节点的 endIndex 移动到了 C，新节点的 startIndex 移动到了 C。</p><p><img src="https://my-blogimage.oss-cn-qingdao.aliyuncs.com/img/diff03.png" alt="diff 第一次循环"></p><p>紧接着开始第二次循环，第二次循环后，同样是旧节点的末尾和新节点的开头（都是 C）相同，同理，diff 后创建了 C 的真实节点插入到第一次创建的 B节点的后面。同时旧节点的 endIndex 移动到了 B，新节点的 startIndex 移动到了 E。</p><p><img src="https://my-blogimage.oss-cn-qingdao.aliyuncs.com/img/diff04.png" alt="diff 第二次循环"></p><p>接下来第三次循环中，发现 patchVnode 的 4 种情形都不符合，于斯在旧节点队列中查找当前的新节点 E，结果发现没有找到，这时候只能直接创建新的真实节点 E，插入到第二次创建的 C 节点之后。同时新节点的 startIndex 移动到了 A。旧节点的 startIndex 和 endIndex 都保持不动。</p><p><img src="https://my-blogimage.oss-cn-qingdao.aliyuncs.com/img/diff05.png" alt="diff 第三次循环"></p><p>第四次循环中，发现了新旧节点的开头（都是 A）相同，于是 diff 后创建了 A 的真实节点，插入到前一次创建的 E 节点后面。同时旧节点的 startIndex 移动到了 B，新节点的 startINdex 移动到了 B。</p><p><img src="https://my-blogimage.oss-cn-qingdao.aliyuncs.com/img/diff06.png" alt="diff 第四次循环"></p><p>第五次循环中，情形同第四次循环一样，因此 diff 后创建了 B 真实节点插入前一次创建的 A 节点后面。同时旧节点的 startIndex 移动到了 C，新节点的 startIndex 移动到了 F。</p><p><img src="https://my-blogimage.oss-cn-qingdao.aliyuncs.com/img/diff07.png" alt="diff 第五次循环"></p><p>这时候发现新节点的 startIndex 已经大于 endIndex 了。不再满足循环的条件了。因此结束循环，接下来走后面的逻辑</p><h3 id="第三步"><a href="#第三步" class="headerlink" title="第三步"></a>第三步</h3><p>当 while 循环结束后，根据新老节点的数目不同，做相应的节点添加或者删除。若新节点数目大于老节点则需要把读出来的老节点从真实 dom 中删除。至此整个 diff 过程就已经全部完成了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (oldStartIdx &gt; oldEndIdx) &#123;</span><br><span class="line">     <span class="comment">/*全部比较完成以后，发现oldStartIdx &gt; oldEndIdx的话，说明老节点已经遍历完了，新节点比老节点多， 所以这时候多出来的新节点需要一个一个创建出来加入到真实Dom中*/</span></span><br><span class="line">     refElm = isUndef(newCh[newEndIdx + <span class="number">1</span>]) ? <span class="literal">null</span> : newCh[newEndIdx + <span class="number">1</span>].elm</span><br><span class="line">     addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue) <span class="comment">//创建 newStartIdx - newEndIdx 之间的所有节点</span></span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (newStartIdx &gt; newEndIdx) &#123;</span><br><span class="line">     <span class="comment">/*如果全部比较完成以后发现newStartIdx &gt; newEndIdx，则说明新节点已经遍历完了，老节点多于新节点，这个时候需要将多余的老节点从真实Dom中移除*/</span></span><br><span class="line">     removeVnodes(oldCh, oldStartIdx, oldEndIdx) <span class="comment">//移除 oldStartIdx - oldEndIdx 之间的所有节点</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>再回过头看我们的实例，新节点的数目大于旧节点，需要创建 newStartIdx 和 newEndIdx 之间的所有节点。在我们的实例中就是节点 F，因此直接创建 F 节点对应的真实节点放到 B 节点后面即可。</p><p><img src="https://my-blogimage.oss-cn-qingdao.aliyuncs.com/img/diff08.png" alt="diff 第六次循环"></p><p>至此 diff 算法实现</p></div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">沈留白</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://workstudy.top/2020/11/13/Vue-%E7%9A%84-diff-%E7%AE%97%E6%B3%95/">https://workstudy.top/2020/11/13/Vue-%E7%9A%84-diff-%E7%AE%97%E6%B3%95/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://workstudy.top">沈留白の博客</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Vue/">Vue</a></div><div class="post-qr-code"><div class="post-qr-code-item"><img class="post-qr-code__img" src="https://my-blogimage.oss-cn-qingdao.aliyuncs.com/img/%E5%BE%AE%E4%BF%A1%E6%94%AF%E4%BB%98.png"><div class="post-qr-code__desc">微信打赏我</div></div><div class="post-qr-code-item"><img class="post-qr-code__img" src="https://my-blogimage.oss-cn-qingdao.aliyuncs.com/img/%E5%BE%AE%E4%BF%A1%E6%B7%BB%E5%8A%A0%E5%A5%BD%E5%8F%8B.png"><div class="post-qr-code__desc">微信联系我</div></div></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2020/11/17/JS-%E4%B9%8B%E5%87%BD%E6%95%B0%E9%98%B2%E6%8A%96%E5%92%8C%E5%87%BD%E6%95%B0%E8%8A%82%E6%B5%81/"><i class="fa fa-chevron-left"></i><span>JS 之函数防抖和函数节流</span></a></div><div class="next-post pull-right"><a href="/2020/11/11/JS-%E4%B9%8B%E5%8E%9F%E5%9E%8B/"><span>JS 之继承与原型链</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="gitalk-container"></div><script>var gitalk=new Gitalk({clientID:"86e967f96c08ba8d57e3",clientSecret:"d584b2bb75b9b78f14ffc02ce51130fae3fd6558",repo:"blogtalk",owner:"SnowySound",admin:"SnowySound",id:md5(decodeURI(location.pathname)),language:"zh-CN"});gitalk.render("gitalk-container")</script></div></div><footer class="footer-bg" style="background-image:url(https://my-blogimage.oss-cn-qingdao.aliyuncs.com/img/home.png)"><div class="layout" id="footer"><div class="copyright">&copy;2019 - 2023 By 沈留白</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody" target="_blank" rel="noopener"><span>Melody</span></a></div><div class="footer_custom_text"><a href="https://beian.miit.gov.cn" target="_blank" rel="noopener">鲁ICP备19020181号</a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.7.0"></script><script src="/js/fancybox.js?version=1.7.0"></script><script src="/js/sidebar.js?version=1.7.0"></script><script src="/js/copy.js?version=1.7.0"></script><script src="/js/transition.js?version=1.7.0"></script><script src="/js/scroll.js?version=1.7.0"></script><script src="/js/head.js?version=1.7.0"></script><script src="/js/search/local-search.js"></script><script>/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)&&($("#nav").addClass("is-mobile"),$("footer").addClass("is-mobile"),$("#top-container").addClass("is-mobile"))</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="noopener" style="color:#49b1f5">hexo-generator-search</a> <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({log:!1,pluginJsPath:"lib/",pluginModelPath:"assets/",pluginRootPath:"live2dw/",tagMode:!1})</script></body></html>